# Difyコーディングルール改善案

## 1. 全体コーディングルール改善案

### 1.1 ナレッジベース管理（新規追加セクション）

#### 現状の問題：
- ダミーIDの使用が常態化
- 実際のナレッジベースIDへの置き換えプロセスが不明確
- 開発時にナレッジベースの事前準備が考慮されていない

#### 改善案：
```yaml
## 5. ナレッジベース管理（新規追加）

### 5.1 knowledge-retrievalノードの使用ルール
- **絶対禁止**: ダミーIDをそのまま本番環境で使用すること
- **必須事項**: ナレッジベースは事前にDifyで作成し、実際のIDを取得すること
- **推奨事項**: 環境変数やコメントでIDの用途を明記すること

### 5.2 dataset_idsの設定方法
```yaml
# 開発時（コメントで明記）
dataset_ids:
  - "PLACEHOLDER_TECH_KB"  # 技術FAQナレッジベース用
  - "PLACEHOLDER_PRODUCT_KB"  # 製品情報ナレッジベース用

# 実装時（実際のIDに置換）
dataset_ids:
  - "actual-knowledge-base-id-from-dify"
```

### 5.3 ナレッジベース未設定時のエラーハンドリング
- 検索結果が空の場合の代替処理を必ず実装
- デフォルト回答を準備
- ユーザーへの適切なフィードバック
```

### 1.2 変数参照ルールの明確化

#### 現状の問題：
- advanced-chatモードでの変数参照方法が不統一
- sys.queryの参照方法に誤りが多い

#### 改善案：
```yaml
## 4.6.1.2 advanced-chatモードの変数参照（改訂）

### 正しい変数参照方法：
1. ユーザー入力の参照
   - プロンプト内: {{#sys.query#}}
   - query_variable_selector: [sys, query]
   - ❌ 間違い: [start_node, sys.query]

2. 他ノードの出力参照
   - プロンプト内: {{#node_id.variable_name#}}
   - value_selector: [node_id, variable_name]

### 具体例：
```yaml
# 正しい例
query_variable_selector:
  - sys
  - query

# 間違った例
query_variable_selector:
  - start_node
  - sys.query  # この形式は無効
```
```

## 2. コンポーネント別コーディングルール改善案

### 2.1 IF_ELSEコンポーネント記述ルール改善

#### 現状の問題：
- デフォルトケースの扱いが不明確
- 条件設計が複雑すぎる
- エラーハンドリングが不十分

#### 改善案：
```yaml
■ベストプラクティス（改訂）

### 条件設計の推奨パターン：
1. **シンプルな2分岐パターン**（推奨）
   - 明確な条件1つで分岐
   - デフォルトケースで残りを処理

2. **3分岐パターン**（最大推奨）
   - 2つの明示的条件
   - デフォルトケースで「その他」を処理
   - 3つ目の条件を明示的に定義する場合は、その意図を明確にする

3. **複雑な分岐の回避**
   - 4つ以上の分岐は避ける
   - 必要な場合は複数のIF_ELSEノードに分割
   - または、LLMノードで分類してから単純な分岐

### デフォルトケース（false）の明確化：
- 必ずデフォルトケースの処理を定義
- "その他"や"該当なし"として明示的に扱う
- エラーハンドリングとしても機能させる
```

### 2.2 知識検索コンポーネント記述ルール改善

#### 現状の問題：
- ダミーIDの使用方法が不適切
- エラーハンドリングがない
- 検索モードの選択基準が不明確

#### 改善案：
```yaml
■注意事項（改訂）
- データセットIDは事前にDifyで作成されたものを指定（開発時の仮IDは明確に区別）
- **開発時は"PLACEHOLDER_"プレフィックスを使用して仮IDであることを明示**
- retrieval_modeがmultipleの場合、multiple_retrieval_configの設定推奨
- **検索結果が空の場合の処理を必ず実装（後続のLLMノードで対応）**
- selected: falseは必須（trueにするとエラーの可能性）

■エラーハンドリングの実装例（新規追加）
```yaml
# 知識検索後のLLMノードで実装
prompt_template:
  - role: system
    text: |
      検索結果を基に回答を生成してください。
      検索結果が空の場合は、一般的な回答を提供してください。
  - role: user
    text: |
      質問: {{#sys.query#}}
      検索結果: {{#knowledge_node.result#}}
      
      検索結果が空の場合の代替回答:
      申し訳ございません。該当する情報が見つかりませんでした。
      サポートセンターまでお問い合わせください。
```
```

## 3. 品質チェックリスト改善案

### 3.1 ナレッジベース関連チェック項目（新規追加）

```yaml
### 4.6.1 knowledge-retrievalノード（追加項目）
- [ ] **すべてのdataset_idsが実際のDifyナレッジベースIDである**
- [ ] **開発用の仮IDを使用していない（PLACEHOLDER_等）**
- [ ] **検索結果が空の場合のエラーハンドリングが実装されている**
- [ ] **適切な検索モード（single/multiple）が選択されている**
```

### 3.2 変数参照チェック項目（改訂）

```yaml
### 5.1 変数参照（改訂）
- [ ] advanced-chatモードでsys.queryを正しく参照している
- [ ] query_variable_selectorが[sys, query]形式である
- [ ] 条件分岐後の変数参照が適切である
- [ ] 実行されない可能性があるノードの変数を参照していない
```

## 4. クラッシュ事項チェックリスト改善案

### 4.1 ナレッジベース関連（新規追加）

```yaml
## 11.4 knowledge-retrievalノードの必須チェック（新規追加）
- [ ] **すべてのdataset_idsが64文字の実際のID形式である**
- [ ] **"PLACEHOLDER_"や"DUMMY_"等のプレフィックスが含まれていない**
- [ ] **テスト環境で実際に検索が成功することを確認している**
```

## 5. 開発プロセスの改善提案

### 5.1 ナレッジベース準備フロー（新規）

1. **開発前準備**
   - Difyでナレッジベースを作成
   - 実際のIDを取得して記録
   - 開発者間で共有

2. **開発時**
   - 仮IDには必ず"PLACEHOLDER_"プレフィックスを付ける
   - コメントで実際の用途を明記

3. **実装時**
   - チェックリストで仮IDの置き換えを確認
   - 動作テストで検索が成功することを確認

### 5.2 IF_ELSE設計ガイドライン（新規）

1. **設計前の検討事項**
   - 本当に条件分岐が必要か？
   - LLMノードで処理できないか？
   - 条件数は3つ以下に収まるか？

2. **実装時の注意**
   - デフォルトケースの意味を明確に
   - すべての条件が排他的であることを確認
   - エラーハンドリングを考慮

## 6. 全体的な改善方針

1. **シンプルさの追求**
   - 複雑な分岐構造を避ける
   - 直線的なフローを優先
   - 必要最小限のノード数

2. **エラーハンドリングの強化**
   - すべての異常系を考慮
   - ユーザーへの適切なフィードバック
   - デフォルト処理の準備

3. **開発プロセスの明確化**
   - 事前準備の重要性
   - チェックリストの活用
   - テスト環境での検証

これらの改善により、「動作はするがエラーが出る」状態を防止し、より堅牢なワークフローの開発が可能になります。